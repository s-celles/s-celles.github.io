---
title: 
draft: false
---
## Distinction entre programmation parallèle et programmation distribuée

Il est crucial de distinguer la programmation parallèle de la programmation distribuée, bien que Julia offre des outils pour les deux approches. La programmation parallèle implique généralement l'utilisation de multiples cœurs ou threads sur une seule machine, partageant la même mémoire. En Julia, cela se fait principalement, comme vu précédemment, via le module `Threads`, avec des constructions comme `Threads.@threads`. Cette approche est efficace pour exploiter pleinement les capacités d'un seul ordinateur multi-cœurs.

En revanche, la programmation distribuée, réalisée via le module `Distributed`, implique l'utilisation de plusieurs processus qui peuvent s'exécuter sur des machines distinctes, chacun avec sa propre mémoire. Ces processus communiquent par passage de messages. Cette approche est nécessaire pour les calculs à grande échelle qui dépassent les capacités d'une seule machine.

Julia permet une transition relativement fluide entre ces deux paradigmes. Par exemple, une boucle parallélisée avec `Threads.@threads` sur une machine peut souvent être adaptée pour utiliser `@distributed` sur un cluster avec des changements minimes. Cependant, la programmation distribuée nécessite généralement une réflexion supplémentaire sur la gestion des données et la communication entre les processus.

Dans le contexte de notre mini cluster, nous nous concentrerons principalement sur la programmation distribuée, qui nous permettra d'exploiter pleinement les ressources de plusieurs machines. Néanmoins, comprendre la programmation parallèle reste important, car elle peut être combinée avec des approches distribuées pour optimiser les performances sur chaque nœud du cluster.

## HPC (High-Performance Computing) ou HTC (High-Throughput Computing) ?

Le calcul haute performance (HPC) et le calcul à haut débit (HTC) sont deux paradigmes distincts dans le domaine du calcul avancé, chacun répondant à des besoins spécifiques en matière de traitement de données et de résolution de problèmes complexes.

**Calcul haute performance (HPC)**

Le HPC se concentre sur la résolution de problèmes complexes et étroitement couplés dans le temps le plus court possible. Il est caractérisé par :

1. **Architecture** : Utilisation de supercalculateurs ou de clusters de calcul avec des nœuds fortement interconnectés.
2. **Communication** : Nécessite généralement une communication fréquente et rapide entre les nœuds de calcul.
3. **Applications typiques** : Simulations climatiques, dynamique des fluides, modélisation moléculaire, etc.
4. **Parallélisme** : Exploite souvent le parallélisme à grain fin, où un problème est divisé en de nombreuses petites tâches interdépendantes.
5. **Latence** : Très sensible à la latence du réseau et à la vitesse de communication entre les nœuds.

**Calcul à haut débit (HTC)**

Le HTC, en revanche, se concentre sur l'exécution efficace d'un grand nombre de tâches indépendantes ou faiblement couplées. Ses caractéristiques principales sont :

1. **Architecture** : Peut utiliser des ressources plus hétérogènes, y compris des grilles de calcul ou des clouds.
2. **Communication** : Les tâches nécessitent généralement peu ou pas de communication entre elles.
3. **Applications typiques** : Analyse de données à grande échelle, simulations paramétriques, rendus graphiques, etc.
4. **Parallélisme** : Exploite le parallélisme à gros grain, où de grandes tâches indépendantes sont exécutées simultanément.
5. **Tolérance aux pannes** : Généralement plus robuste face aux pannes de nœuds individuels.

**Comparaison et choix**

Le choix entre HPC et HTC dépend de la nature du problème à résoudre :
- Le HPC est préférable pour des problèmes qui nécessitent une forte interaction entre les différentes parties du calcul et où la performance globale dépend de la rapidité de chaque étape.
- Le HTC est plus adapté pour des problèmes qui peuvent être décomposés en tâches indépendantes, où l'objectif est de maximiser le nombre total de tâches accomplies sur une période donnée.

Dans le contexte de notre mini cluster et de l'exemple de l'équation du cercle, nous nous situons davantage dans le paradigme HTC. Notre problème peut être facilement divisé en tâches indépendantes (évaluation de différentes régions de l'espace), ce qui correspond bien à l'approche HTC. Cependant, Julia, avec ses capacités de calcul distribué, peut être utilisée efficacement dans les deux contextes, HPC et HTC, en fonction de la configuration du cluster et de la nature du problème traité.

## Fonctionnement du calcul distribué en Julia

### Principe

Le calcul distribué en Julia repose sur le concept de parallélisme à mémoire distribuée, où plusieurs processus Julia indépendants collaborent pour résoudre un problème commun. Julia facilite cette approche grâce à son module `Distributed` intégré, qui offre des primitives puissantes pour la programmation parallèle et distribuée.

Au cœur du calcul distribué avec Julia se trouve la notion de "workers" (travailleurs). Chaque worker est un processus Julia distinct qui peut s'exécuter sur la même machine ou sur des machines différentes au sein d'un réseau. Ces workers peuvent communiquer entre eux et avec le processus principal, appelé "master", pour échanger des données et des tâches. L'ajout de workers se fait simplement avec la fonction `addprocs()`, qui peut prendre en argument des adresses IP pour distribuer le calcul sur plusieurs machines.

Julia propose plusieurs mécanismes pour exploiter ces workers. La macro `@distributed` permet de paralléliser facilement des boucles, répartissant automatiquement les itérations entre les workers disponibles. Pour des tâches plus complexes, la fonction `remotecall()` permet d'exécuter des fonctions spécifiques sur des workers choisis, tandis que `pmap()` offre une interface de haut niveau pour appliquer une fonction à une collection de données de manière distribuée. Ces outils, combinés à la capacité de Julia à sérialiser et désérialiser efficacement les données et le code, permettent de créer des applications distribuées performantes avec relativement peu d'effort de programmation.

Un aspect crucial du calcul distribué en Julia est la gestion de l'état et de la synchronisation entre les workers. Julia facilite cela grâce à des constructions comme `@everywhere`, qui permet de définir des fonctions et des variables sur tous les workers simultanément, et les "Future" et "RemoteChannel", qui offrent des mécanismes pour la communication asynchrone et la synchronisation entre les processus. Ces fonctionnalités permettent aux développeurs de concevoir des algorithmes distribués complexes tout en maintenant un code clair et expressif, fidèle à la philosophie de Julia qui vise à combiner la simplicité de la syntaxe avec des performances de haut niveau.

La documentation officielle de Julia permet d'en savoir davantage sur le sujet https://docs.julialang.org/en/v1/manual/distributed-computing/

### Exemple de code Julia distribué

Reprenons le cas du calcul des solutions de (x - 1)² + (y - 2)² - 1 = 0 

```julia
using Distributed

# Ajouter des processus workers (ajustez selon vos besoins)
addprocs(3)

@everywhere function f(x, y)
    return (x - 1)^2 + (y - 2)^2 - 1
end

@everywhere function solve(x_range, y_range, tolerance=1e-6)
    points = Tuple{Float64, Float64}[]
    for x in x_range, y in y_range
        if abs(circle_equation(x, y)) < tolerance
            push!(points, (x, y))
        end
    end
    return points
end

# Définir l'espace de recherche
x_range = range(-10, 10, length=1000)
y_range = range(-10, 10, length=1000)

# Diviser l'espace de recherche pour la distribution
chunks = Iterators.partition(x_range, length(x_range) ÷ nworkers())

# Effectuer le calcul distribué
@time begin
    results = @distributed (vcat) for chunk in chunks
        find_points_on_circle(chunk, y_range)
    end
end

println("Nombre de points trouvés : ", length(results))
println("Quelques points trouvés : ", results[1:5])
```

### Analyse de ce code

Cet exemple illustre plusieurs concepts clés du calcul distribué appliqués à un problème mathématique concret : la recherche de points satisfaisant l'équation d'un cercle dans un espace bidimensionnel.

1. **Principe du calcul distribué**
   Le calcul distribué consiste à diviser un problème complexe en sous-tâches qui peuvent être traitées simultanément par plusieurs unités de calcul. Dans notre cas, nous divisons l'espace de recherche en plusieurs parties, chacune traitée par un processus différent.

2. **Adaptation du problème au calcul distribué**
   L'équation du cercle (x - 1)² + (y - 2)² = 1 se prête bien à la parallélisation car chaque point (x, y) peut être évalué indépendamment des autres. Cela permet une distribution efficace du travail sans nécessiter de communication complexe entre les processus.

3. **Utilisation des ressources du cluster**
   Bien que l'exemple utilise des processus locaux (`addprocs(3)`), dans un véritable environnement de cluster, nous pourrions spécifier les adresses IP des différentes machines. Cela permettrait d'exploiter pleinement les ressources de calcul distribuées sur plusieurs ordinateurs.

4. **Équilibrage de charge**
   La division de l'espace de recherche en "chunks" égaux (`Iterators.partition`) assure une répartition équilibrée du travail entre les workers. Dans un cluster hétérogène, on pourrait envisager des stratégies plus sophistiquées pour adapter la charge à la puissance de chaque nœud.

5. **Scalabilité**
   Ce code est facilement scalable. En augmentant simplement le nombre de workers (en modifiant `addprocs(3)` ou en ajoutant plus de machines au cluster), nous pouvons traiter des espaces de recherche plus grands ou obtenir des résultats plus rapidement.

6. **Gestion de la mémoire distribuée**
   Chaque worker opère sur sa propre portion de données, ce qui permet de gérer efficacement la mémoire, surtout pour de très grands espaces de recherche qui ne tiendraient pas dans la mémoire d'une seule machine.

7. **Agrégation des résultats**
   L'utilisation de `@distributed (vcat)` montre comment les résultats partiels de chaque worker sont combinés en un résultat final unique.

8. **Flexibilité et adaptabilité**
   Ce modèle de calcul peut être facilement adapté à d'autres problèmes similaires. Par exemple, on pourrait modifier la fonction `circle_equation` pour résoudre d'autres équations ou problèmes d'optimisation.

9. **Performance et mesure**
   L'utilisation de `@time` permet de mesurer les performances, ce qui est crucial pour évaluer l'efficacité de la distribution et identifier les goulots d'étranglement potentiels.

Dans le contexte de notre mini cluster, cet exemple sert de base pour comprendre comment structurer des problèmes plus complexes. Il démontre comment Julia peut être utilisé pour exploiter efficacement les ressources distribuées, que ce soit sur plusieurs cœurs d'une même machine ou sur plusieurs machines d'un cluster.

La simplicité relative de cet exemple ne doit pas masquer son potentiel : des principes similaires peuvent être appliqués à des calculs scientifiques beaucoup plus complexes, des simulations, ou des analyses de données massives, où la distribution du calcul devient non seulement avantageuse mais souvent nécessaire.

#julialang #calcul_distribué
